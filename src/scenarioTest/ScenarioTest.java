package scenarioTest;

import personnages.Gaulois;
import produit.Poisson;
import produit.Produit;
import produit.Sanglier;
import villagegaulois.Etal;
import villagegaulois.IEtal;

public class ScenarioTest {
	public static void main(String[] args) {
//		Etal[] marche = new Etal[3];
// 		// Etal is a raw type. References to generic type Etal<P> should be parameterized
//		Etal<Sanglier> etalSanglier = new Etal<>();
//		Etal<Poisson> etalPoisson = new Etal<>();
//		marche[0] = etalSanglier;
//		marche[1] = etalPoisson; 
		
//		IEtal<Produit>[] marche = new IEtal[3]; 
//		//The expression of type IEtal[] needs unchecked conversion to conform to IEtal<Sanglier>[]
//		Etal<Sanglier> etalSanglier = new Etal<>();
//		Etal<Poisson> etalPoisson = new Etal<>();
//		marche[0] = etalSanglier;
//		marche[1] = etalPoisson;
		
//        Etal<Sanglier> etalSanglier = new Etal<>();
//        // Modifier la déclaration de la variable "marche" pour préciser que ses étals acceptent uniquement des sangliers
//        Etal<Sanglier>[] marche = new Etal[3];
//        // Placer l'étal de sanglier sur le marché
//        marche[0] = etalSanglier; // Cela est possible car la variable "marche" accepte uniquement des étals de sanglier

//		IEtal[] etals = new IEtal[3];
//		Etal etalSanglier = new Etal();
//		etals[0] = etalSanglier;
//		etals[0].occuperEtal(new Gaulois("Ordralfabétix", 12), new Poisson("lundi"), 10);
		
//		c. Au final il n’y a donc aucun contrôle de type et un poisson sera stocké là où un
//		sanglier était attendu. Ainsi on peut vendre du poisson sur un étal de sanglier.


	}
	
}